Class,Method,Parameter Names,Observed Arg Types,Observed Return Type,Source Code,Comments
MiniMagick::Image,initialize,"input_path, tempfile, block","input_path => (Pathname or String)
tempfile => Tempfile
block => nil
",MiniMagick::Image,"    def initialize(input_path, tempfile = nil, &block)
      @path = input_path.to_s
      @tempfile = tempfile
      @info = MiniMagick::Image::Info.new(@path)

      combine_options(&block) if block
    end
","##
# Create a new {MiniMagick::Image} object.
#
# _DANGER_: The file location passed in here is the *working copy*. That
# is, it gets *modified*. You can either copy it yourself or use {.open}
# which creates a temporary file for you and protects your original.
#
# @param input_path [String, Pathname] The location of an image file
# @yield [MiniMagick::Tool::Mogrify] If block is given, {#combine_options}
#   is called.
#
"
MiniMagick::Image,==,other,"other => MiniMagick::Image
",(false or true),"    def ==(other)
      self.class == other.class && signature == other.signature
    end
",""
MiniMagick::Image,hash,"","",Integer,"    def hash
      signature.hash
    end
",""
MiniMagick::Image,valid?,"","",(false or true),"    def valid?
      validate!
      true
    rescue MiniMagick::Invalid
      false
    end
","##
# Checks to make sure that MiniMagick can read the file and understand it.
#
# This uses the 'identify' command line utility to check the file. If you
# are having issues with this, then please work directly with the
# 'identify' command and see if you can figure out what the issue is.
#
# @return [Boolean]
#
"
MiniMagick::Image,validate!,"","",String,"    def validate!
      identify
    rescue MiniMagick::Error => error
      raise MiniMagick::Invalid, error.message
    end
","##
# Runs `identify` on the current image, and raises an error if it doesn't
# pass.
#
# @raise [MiniMagick::Invalid]
#
"
MiniMagick::Image,[],value,"value => (String or Symbol)
",(Array<Integer> or Integer or String),"    def [](value)
      @info[value.to_s]
    end
","##
# Use this method if you want to access raw Identify's format API.
#
# @example
#    image[""%w %h""]       #=> ""250 450""
#    image[""%r""]          #=> ""DirectClass sRGB""
#
# @param value [String]
# @see http://www.imagemagick.org/script/escape.php
# @return [String]
#
"
MiniMagick::Image,layers,"","",Array<MiniMagick::Image>,"    def layers
      layers_count = identify.lines.count
      layers_count.times.map do |idx|
        MiniMagick::Image.new(""#{path}[#{idx}]"")
      end
    end
","##
# Returns layers of the image. For example, JPEGs are 1-layered, but
# formats like PSDs, GIFs and PDFs can have multiple layers/frames/pages.
#
# @example
#   image = MiniMagick::Image.new(""document.pdf"")
#   image.pages.each_with_index do |page, idx|
#     page.write(""page#{idx}.pdf"")
#   end
# @return [Array<MiniMagick::Image>]
#
"
MiniMagick::Image,get_pixels,"","",Array<Array<Array<Integer>>>,"    def get_pixels
      convert = MiniMagick::Tool::Convert.new
      convert << path
      convert.depth(8)
      convert << ""RGB:-""

      # Do not use `convert.call` here. We need the whole binary (unstripped) output here.
      shell = MiniMagick::Shell.new
      output, * = shell.run(convert.command)

      pixels_array = output.unpack(""C*"")
      pixels = pixels_array.each_slice(3).each_slice(width).to_a

      # deallocate large intermediary objects
      output.clear
      pixels_array.clear

      pixels
    end
","##
# Returns a matrix of pixels from the image. The matrix is constructed as
# an array (1) of arrays (2) of arrays (3) of unsigned integers:
#
# 1) one for each row of pixels
# 2) one for each column of pixels
# 3) three elements in the range 0-255, one for each of the RGB color channels
#
# @example
#   img = MiniMagick::Image.open 'image.jpg'
#   pixels = img.get_pixels
#   pixels[3][2][1] # the green channel value from the 4th-row, 3rd-column pixel
#
# It can also be called after applying transformations:
#
# @example
#   img = MiniMagick::Image.open 'image.jpg'
#   img.crop '20x30+10+5'
#   img.colorspace 'Gray'
#   pixels = img.get_pixels
#
# In this example, all pixels in pix should now have equal R, G, and B values.
#
# @return [Array] Matrix of each color of each pixel
"
MiniMagick::Image,format,"format, page, read_opts","format => String
page => Integer
read_opts => (Hash<%bot, %bot> or Hash<Symbol, String>)
",MiniMagick::Image,"    def format(format, page = 0, read_opts={})
      if @tempfile
        new_tempfile = MiniMagick::Utilities.tempfile("".#{format}"")
        new_path = new_tempfile.path
      else
        new_path = Pathname(path).sub_ext("".#{format}"").to_s
      end

      input_path = path.dup
      input_path << ""[#{page}]"" if page && !layer?

      MiniMagick::Tool::Convert.new do |convert|
        read_opts.each do |opt, val|
          convert.send(opt.to_s, val)
        end
        convert << input_path
        yield convert if block_given?
        convert << new_path
      end

      if @tempfile
        destroy!
        @tempfile = new_tempfile
      else
        File.delete(path) unless path == new_path || layer?
      end

      path.replace new_path
      @info.clear

      self
    end
","##
# This is used to change the format of the image. That is, from ""tiff to
# jpg"" or something like that. Once you run it, the instance is pointing to
# a new file with a new extension!
#
# *DANGER*: This renames the file that the instance is pointing to. So, if
# you manually opened the file with Image.new(file_path)... Then that file
# is DELETED! If you used Image.open(file) then you are OK. The original
# file will still be there. But, any changes to it might not be...
#
# Formatting an animation into a non-animated type will result in
# ImageMagick creating multiple pages (starting with 0).  You can choose
# which page you want to manipulate.  We default to the first page.
#
# If you would like to convert between animated formats, pass nil as your
# page and ImageMagick will copy all of the pages.
#
# @param format [String] The target format... Like 'jpg', 'gif', 'tiff' etc.
# @param page [Integer] If this is an animated gif, say which 'page' you
#   want with an integer. Default 0 will convert only the first page; 'nil'
#   will convert all pages.
# @param read_opts [Hash] Any read options to be passed to ImageMagick
#   for example: image.format('jpg', page, {density: '300'})
# @yield [MiniMagick::Tool::Convert] It optionally yields the command,
#   if you want to add something.
# @return [self]
#
"
MiniMagick::Image,combine_options,block,"block => nil
",MiniMagick::Image,"    def combine_options(&block)
      mogrify(&block)
    end
","##
# You can use multiple commands together using this method. Very easy to
# use!
#
# @example
#   image.combine_options do |c|
#     c.draw ""image Over 0,0 10,10 '#{MINUS_IMAGE_PATH}'""
#     c.thumbnail ""300x500>""
#     c.background ""blue""
#   end
#
# @yield [MiniMagick::Tool::Mogrify]
# @see http://www.imagemagick.org/script/mogrify.php
# @return [self]
#
"
MiniMagick::Image,method_missing,"name, args","name => Symbol
args => Array<RDL::Type::NominalType>
",MiniMagick::Image,"    def method_missing(name, *args)
      mogrify do |builder|
        builder.send(name, *args)
      end
    end
","##
# If an unknown method is called then it is sent through the mogrify
# program.
#
# @see http://www.imagemagick.org/script/mogrify.php
# @return [self]
#
"
MiniMagick::Image,respond_to_missing?,"method_name, include_private","method_name => Symbol
include_private => false
",(false or true),"    def respond_to_missing?(method_name, include_private = false)
      MiniMagick::Tool::Mogrify.option_methods.include?(method_name.to_s)
    end
",""
MiniMagick::Image,write,output_to,"output_to => (Pathname or String or StringIO)
",(Integer or String),"    def write(output_to)
      case output_to
      when String, Pathname
        if layer?
          MiniMagick::Tool::Convert.new do |builder|
            builder << path
            builder << output_to
          end
        else
          FileUtils.copy_file path, output_to unless path == output_to.to_s
        end
      else
        IO.copy_stream File.open(path, ""rb""), output_to
      end
    end
","##
# Writes the temporary file out to either a file location (by passing in a
# String) or by passing in a Stream that you can #write(chunk) to
# repeatedly
#
# @param output_to [String, Pathname, #read] Some kind of stream object
#   that needs to be read or a file path as a String
#
"
MiniMagick::Image,composite,"other_image, output_extension, mask","other_image => MiniMagick::Image
output_extension => String
mask => MiniMagick::Image
",MiniMagick::Image,"    def composite(other_image, output_extension = ""format"", mask = nil)
      output_tempfile = MiniMagick::Utilities.tempfile("".#{output_extension}"")

      MiniMagick::Tool::Composite.new do |composite|
        yield composite if block_given?
        composite << other_image.path
        composite << path
        composite << mask.path if mask
        composite << output_tempfile.path
      end

      Image.new(output_tempfile.path, output_tempfile)
    end
","##
# @example
#  first_image = MiniMagick::Image.open ""first.jpg""
#  second_image = MiniMagick::Image.open ""second.jpg""
#  result = first_image.composite(second_image) do |c|
#    c.compose ""Over"" # OverCompositeOp
#    c.geometry ""+20+20"" # copy second_image onto first_image from (20, 20)
#  end
#  result.write ""output.jpg""
#
# @see http://www.imagemagick.org/script/composite.php
#
"
MiniMagick::Image,destroy!,"","",true,"    def destroy!
      if @tempfile
        FileUtils.rm_f @tempfile.path.sub(/mpc$/, ""cache"") if @tempfile.path.end_with?("".mpc"")
        @tempfile.unlink
      end
    end
","##
# Destroys the tempfile (created by {.open}) if it exists.
#
"
MiniMagick::Image,identify,"","",String,"    def identify
      MiniMagick::Tool::Identify.new do |builder|
        yield builder if block_given?
        builder << path
      end
    end
","##
# Runs `identify` on itself. Accepts an optional block for adding more
# options to `identify`.
#
# @example
#   image = MiniMagick::Image.open(""image.jpg"")
#   image.identify do |b|
#     b.verbose
#   end # runs `identify -verbose image.jpg`
# @return [String] Output from `identify`
# @yield [MiniMagick::Tool::Identify]
#
"
MiniMagick::Image,mogrify,page,"page => nil
",MiniMagick::Image,"    def mogrify(page = nil)
      MiniMagick::Tool::MogrifyRestricted.new do |builder|
        yield builder if block_given?
        builder << (page ? ""#{path}[#{page}]"" : path)
      end

      @info.clear

      self
    end
",""
MiniMagick::Image,layer?,"","",Integer,"    def layer?
      path =~ /\[\d+\]$/
    end
",""
MiniMagick::Tool,initialize,"name, options","name => String
options => (Hash<%bot, %bot> or Hash<Symbol, false>)
",(false or true),"    def initialize(name, options = {})
      warn ""MiniMagick::Tool.new(false) is deprecated and will be removed in MiniMagick 5, use MiniMagick::Tool.new(whiny: false) instead."" if !options.is_a?(Hash)

      @name  = name
      @args  = []
      @whiny = options.is_a?(Hash) ? options.fetch(:whiny, MiniMagick.whiny) : options
    end
","# @param whiny [Boolean] Whether to raise errors on exit codes different
#   than 0.
# @example
#   MiniMagick::Tool::Identify.new(whiny: false) do |identify|
#     identify.help # returns exit status 1, which would otherwise throw an error
#   end
"
MiniMagick::Tool,call,args,"args => (Array<%bot> or Array<RDL::Type::GenericType>)
",String,"    def call(*args)
      options = args[-1].is_a?(Hash) ? args.pop : {}
      warn ""Passing whiny to MiniMagick::Tool#call is deprecated and will be removed in MiniMagick 5, use MiniMagick::Tool.new(whiny: false) instead."" if args.any?
      whiny = args.fetch(0, @whiny)

      options[:whiny] = whiny
      options[:stderr] = false if block_given?

      shell = MiniMagick::Shell.new
      stdout, stderr, status = shell.run(command, options)
      yield stdout, stderr, status if block_given?

      stdout.chomp(""\n"")
    end
","##
# Executes the command that has been built up.
#
# @example
#   mogrify = MiniMagick::Tool::Mogrify.new
#   mogrify.resize(""500x500"")
#   mogrify << ""path/to/image.jpg""
#   mogrify.call # executes `mogrify -resize 500x500 path/to/image.jpg`
#
# @example
#   mogrify = MiniMagick::Tool::Mogrify.new
#   # build the command
#   mogrify.call do |stdout, stderr, status|
#     # ...
#   end
#
# @yield [Array] Optionally yields stdout, stderr, and exit status
#
# @return [String] Returns the output of the command
#
"
MiniMagick::Tool,command,"","",Array<String>,"    def command
      [*executable, *args]
    end
","##
# The currently built-up command.
#
# @return [Array<String>]
#
# @example
#   mogrify = MiniMagick::Tool::Mogrify.new
#   mogrify.resize ""500x500""
#   mogrify.contrast
#   mogrify.command #=> [""mogrify"", ""-resize"", ""500x500"", ""-contrast""]
#
"
MiniMagick::Tool,executable,"","",Array<String>,"    def executable
      exe = [name]
      exe.unshift ""magick"" if MiniMagick.imagemagick7? && name != ""magick""
      exe.unshift ""gm"" if MiniMagick.graphicsmagick?
      exe.unshift File.join(MiniMagick.cli_path, exe.shift) if MiniMagick.cli_path
      Array(MiniMagick.cli_prefix).reverse_each { |p| exe.unshift p } if MiniMagick.cli_prefix
      exe
    end
","##
# The executable used for this tool. Respects
# {MiniMagick::Configuration#cli}, {MiniMagick::Configuration#cli_path},
# and {MiniMagick::Configuration#cli_prefix}.
#
# @return [Array<String>]
#
# @example
#   MiniMagick.configure { |config| config.cli = :graphicsmagick }
#   identify = MiniMagick::Tool::Identify.new
#   identify.executable #=> [""gm"", ""identify""]
#
# @example
#   MiniMagick.configure do |config|
#     config.cli = :graphicsmagick
#     config.cli_prefix = ['firejail', '--force']
#   end
#   identify = MiniMagick::Tool::Identify.new
#   identify.executable #=> [""firejail"", ""--force"", ""gm"", ""identify""]
#
"
MiniMagick::Tool,<<,arg,"arg => (Integer or String)
",(MiniMagick::Tool::Composite or MiniMagick::Tool::Convert or MiniMagick::Tool::Identify or MiniMagick::Tool::Mogrify),"    def <<(arg)
      args << arg.to_s
      self
    end
","##
# Appends raw options, useful for appending image paths.
#
# @return [self]
#
"
MiniMagick::Tool,merge!,new_args,"new_args => (Array<%bot> or Array<Integer> or Array<String>)
",(MiniMagick::Tool::Convert or MiniMagick::Tool::Identify or MiniMagick::Tool::MogrifyRestricted),"    def merge!(new_args)
      new_args.each { |arg| self << arg }
      self
    end
","##
# Merges a list of raw options.
#
# @return [self]
#
"
MiniMagick::Tool,method_missing,"name, args","name => Symbol
args => (Array<%bot> or Array<RDL::Type::NominalType>)
",(MiniMagick::Tool::Convert or MiniMagick::Tool::Identify or MiniMagick::Tool::MogrifyRestricted),"    def method_missing(name, *args)
      option = ""-#{name.to_s.tr('_', '-')}""
      self << option
      self.merge!(args)
      self
    end
","##
# Any undefined method will be transformed into a CLI option
#
#   mogrify = MiniMagick::Tool.new(""mogrify"")
#   mogrify.adaptive_blur(""..."")
#   mogrify.foo_bar
#   mogrify.command.join("" "") ""mogrify -adaptive-blur ... -foo-bar""
#
"
MiniMagick::Shell,run,"command, options","command => Array<String>
options => (Hash<%bot, %bot> or Hash<Symbol, false> or Hash<Symbol, true>)
",Array<(Integer or String)>,"    def run(command, options = {})
      stdout, stderr, status = execute(command, stdin: options[:stdin])

      if status != 0 && options.fetch(:whiny, MiniMagick.whiny)
        fail MiniMagick::Error, ""`#{command.join("" "")}` failed with error:\n#{stderr}""
      end

      $stderr.print(stderr) unless options[:stderr] == false

      [stdout, stderr, status]
    end
",""
MiniMagick::Shell,execute,"command, options","command => Array<String>
options => Hash<Symbol, nil>
",Array<(Integer or String)>,"    def execute(command, options = {})
      stdout, stderr, status =
        log(command.join("" "")) do
          send(""execute_#{MiniMagick.shell_api.gsub(""-"", ""_"")}"", command, options)
        end

      [stdout, stderr, status.exitstatus]
    rescue Errno::ENOENT, IOError
      ["""", ""executable not found: \""#{command.first}\"""", 127]
    end
",""
MiniMagick::Shell,execute_open3,"command, options","command => Array<String>
options => Hash<Symbol, nil>
",Array<(Process::Status or String)>,"    def execute_open3(command, options = {})
      require ""open3""

      # We would ideally use Open3.capture3, but it wouldn't allow us to
      # terminate the command after timing out.
      Open3.popen3(*command) do |in_w, out_r, err_r, thread|
        [in_w, out_r, err_r].each(&:binmode)
        stdout_reader = Thread.new { out_r.read }
        stderr_reader = Thread.new { err_r.read }
        begin
          in_w.write options[:stdin].to_s
        rescue Errno::EPIPE
        end
        in_w.close

        begin
          Timeout.timeout(MiniMagick.timeout) { thread.join }
        rescue Timeout::Error
          Process.kill(""TERM"", thread.pid) rescue nil
          Process.waitpid(thread.pid)      rescue nil
          raise Timeout::Error, ""MiniMagick command timed out: #{command}""
        end

        [stdout_reader.value, stderr_reader.value, thread.value]
      end
    end
",""
MiniMagick::Shell,log,"command, block","command => String
block => nil
",Array<(Process::Status or String)>,"    def log(command, &block)
      value = nil
      duration = Benchmark.realtime { value = block.call }
      MiniMagick.logger.debug ""[%.2fs] %s"" % [duration, command]
      value
    end
",""
MiniMagick::Configuration,configure,"","",nil,"    def configure
      yield self
    end
","##
# @yield [self]
# @example
#   MiniMagick.configure do |config|
#     config.cli = :graphicsmagick
#     config.timeout = 5
#   end
#
"
MiniMagick::Configuration,processor,"","",String,"    def processor
      @processor ||= CLI_DETECTION.values.detect do |processor|
        MiniMagick::Utilities.which(processor)
      end
    end
","# @private (for backwards compatibility)
"
MiniMagick::Configuration,cli,"","",Symbol,"    def cli
      if instance_variable_defined?(""@cli"")
        instance_variable_get(""@cli"")
      else
        cli = CLI_DETECTION.key(processor) or
          fail MiniMagick::Error, ""You must have ImageMagick or GraphicsMagick installed""

        instance_variable_set(""@cli"", cli)
      end
    end
","##
# Get [ImageMagick](http://www.imagemagick.org) or
# [GraphicsMagick](http://www.graphicsmagick.org).
#
# @return [Symbol] `:imagemagick` or `:graphicsmagick`
#
"
MiniMagick::Configuration,cli=,value,"value => Symbol
",nil,"    def cli=(value)
      @cli = value

      if not CLI_DETECTION.key?(@cli)
        raise ArgumentError,
          ""CLI has to be set to either :imagemagick, :imagemagick7 or :graphicsmagick"" \
          "", was set to #{@cli.inspect}""
      end
    end
","##
# Set whether you want to use [ImageMagick](http://www.imagemagick.org) or
# [GraphicsMagick](http://www.graphicsmagick.org).
#
"
MiniMagick::Configuration,cli_path,"","",nil,"    def cli_path
      if instance_variable_defined?(""@cli_path"")
        instance_variable_get(""@cli_path"")
      else
        processor_path = instance_variable_get(""@processor_path"") if instance_variable_defined?(""@processor_path"")

        instance_variable_set(""@cli_path"", processor_path)
      end
    end
","##
# If you set the path of CLI tools, you can get the path of the
# executables.
#
# @return [String]
#
"
MiniMagick::Image::Info,initialize,path,"path => String
","Hash<%bot, %bot>","      def initialize(path)
        @path = path
        @info = {}
      end
",""
MiniMagick::Image::Info,[],"value, args","value => String
args => (Array<%bot> or Array<RDL::Type::NominalType>)
","(Array<Integer> or Hash<%bot, %bot> or Hash<String, (Float or Hash<String, Float> or Hash<String, Hash<String, (Float or Integer)>> or Hash<String, Hash<String, Float>> or Hash<String, Hash<String, Integer>> or Hash<String, Integer> or Hash<String, String> or Integer or String or false)> or Hash<String, (Float or Hash<String, Float> or Hash<String, Hash<String, (Float or Integer)>> or Hash<String, Hash<String, Float>> or Hash<String, Integer> or Hash<String, String> or Integer or String or false)> or Hash<String, (Hash<String, (Hash<String, String> or String)> or Hash<String, Hash<String, String>> or Hash<String, String> or String)> or Hash<String, String> or Integer or String)","      def [](value, *args)
        case value
        when ""format"", ""width"", ""height"", ""dimensions"", ""size"", ""human_size""
          cheap_info(value)
        when ""colorspace""
          colorspace
        when ""mime_type""
          mime_type
        when ""resolution""
          resolution(*args)
        when ""signature""
          signature
        when /^EXIF\:/i
          raw_exif(value)
        when ""exif""
          exif
        when ""details""
          details
        when ""data""
          data
        else
          raw(value)
        end
      end
",""
MiniMagick::Image::Info,clear,"","","Hash<%bot, %bot>","      def clear
        @info.clear
      end
",""
MiniMagick::Image::Info,cheap_info,value,"value => String
",(Array<Integer> or Integer or String),"      def cheap_info(value)
        @info.fetch(value) do
          format, width, height, size = self[""%m %w %h %b""].split("" "")

          path = @path
          path = path.match(/\[\d+\]$/).pre_match if path =~ /\[\d+\]$/

          @info.update(
            ""format""     => format,
            ""width""      => Integer(width),
            ""height""     => Integer(height),
            ""dimensions"" => [Integer(width), Integer(height)],
            ""size""       => File.size(path),
            ""human_size"" => size,
          )

          @info.fetch(value)
        end
      rescue ArgumentError, TypeError
        raise MiniMagick::Invalid, ""image data can't be read""
      end
",""
MiniMagick::Image::Info,colorspace,"","",String,"      def colorspace
        @info[""colorspace""] ||= self[""%r""]
      end
",""
MiniMagick::Image::Info,mime_type,"","",String,"      def mime_type
        ""image/#{self[""format""].downcase}""
      end
",""
MiniMagick::Image::Info,resolution,unit,"unit => String
",Array<Integer>,"      def resolution(unit = nil)
        output = identify do |b|
          b.units unit if unit
          b.format ""%x %y""
        end
        output.split("" "").map(&:to_i)
      end
",""
MiniMagick::Image::Info,raw_exif,value,"value => String
",String,"      def raw_exif(value)
        self[""%[#{value}]""]
      end
",""
MiniMagick::Image::Info,exif,"","","(Hash<%bot, %bot> or Hash<String, String>)","      def exif
        @info[""exif""] ||= (
          hash = {}
          output = self[""%[EXIF:*]""]

          output.each_line do |line|
            line = line.chomp(""\n"")

            case MiniMagick.cli
            when :imagemagick, :imagemagick7
              if match = line.match(/^exif:/)
                key, value = match.post_match.split(""="", 2)
                value = decode_comma_separated_ascii_characters(value) if ASCII_ENCODED_EXIF_KEYS.include?(key)
                hash[key] = value
              else
                hash[hash.keys.last] << ""\n#{line}""
              end
            when :graphicsmagick
              next if line == ""unknown""
              key, value = line.split(""="", 2)
              value.gsub!(""\\012"", ""\n"") # convert ""\012"" characters to newlines
              hash[key] = value
            end
          end

          hash
        )
      end
",""
MiniMagick::Image::Info,raw,value,"value => String
",String,"      def raw(value)
        @info[""raw:#{value}""] ||= identify { |b| b.format(value) }
      end
",""
MiniMagick::Image::Info,signature,"","",String,"      def signature
        @info[""signature""] ||= self[""%#""]
      end
",""
MiniMagick::Image::Info,details,"","","Hash<String, (Hash<String, (Hash<String, String> or String)> or Hash<String, Hash<String, String>> or Hash<String, String> or String)>","      def details
        warn ""[MiniMagick] MiniMagick::Image#details has been deprecated, as it was causing too many parsing errors. You should use MiniMagick::Image#data instead, which differs in a way that the keys are in camelcase."" if MiniMagick.imagemagick? || MiniMagick.imagemagick7?

        @info[""details""] ||= (
          details_string = identify(&:verbose)
          key_stack = []
          details_string.lines.to_a[1..-1].each_with_object({}) do |line, details_hash|
            next if !line.valid_encoding? || line.strip.length.zero?

            level = line[/^\s*/].length / 2 - 1
            if level >= 0
              key_stack.pop until key_stack.size <= level
            else
              # Some metadata, such as SVG clipping paths, will be saved without
              # indentation, resulting in a level of -1
              last_key = details_hash.keys.last
              details_hash[last_key] = '' if details_hash[last_key].empty?
              details_hash[last_key] << line
              next
            end

            key, _, value = line.partition(/:[\s]/).map(&:strip)
            hash = key_stack.inject(details_hash) { |_hash, _key| _hash.fetch(_key) }
            if value.empty?
              hash[key] = {}
              key_stack.push key
            else
              hash[key] = value
            end
          end
        )
      end
",""
MiniMagick::Image::Info,data,"","","(Hash<String, (Float or Hash<String, Float> or Hash<String, Hash<String, (Float or Integer)>> or Hash<String, Hash<String, Float>> or Hash<String, Hash<String, Integer>> or Hash<String, Integer> or Hash<String, String> or Integer or String or false)> or Hash<String, (Float or Hash<String, Float> or Hash<String, Hash<String, (Float or Integer)>> or Hash<String, Hash<String, Float>> or Hash<String, Integer> or Hash<String, String> or Integer or String or false)>)","      def data
        raise Error, ""MiniMagick::Image#data isn't supported on GraphicsMagick. Use MiniMagick::Image#details instead."" if MiniMagick.graphicsmagick?

        @info[""data""] ||= (
          json = MiniMagick::Tool::Convert.new do |convert|
            convert << path
            convert << ""json:""
          end

          data = JSON.parse(json)
          data = data.fetch(0) if data.is_a?(Array)
          data.fetch(""image"")
        )
      end
",""
MiniMagick::Image::Info,identify,"","",String,"      def identify
        MiniMagick::Tool::Identify.new do |builder|
          yield builder if block_given?
          builder << path
        end
      end
",""
MiniMagick::Image::Info,decode_comma_separated_ascii_characters,encoded_value,"encoded_value => String
",String,"      def decode_comma_separated_ascii_characters(encoded_value)
        return encoded_value unless encoded_value.include?(',')
        encoded_value.scan(/\d+/).map(&:to_i).map(&:chr).join
      end
",""
MiniMagick::Image::Info,path,"","",String,"      def path
        value = @path
        value += ""[0]"" unless value =~ /\[\d+\]$/
        value
      end
",""
MiniMagick::Tool::Mogrify,initialize,args,"args => (Array<%bot> or Array<RDL::Type::GenericType>)
",(false or true),"      def initialize(*args)
        super(""mogrify"", *args)
      end
",""
MiniMagick::Tool::Identify,initialize,args,"args => Array<%bot>
",true,"      def initialize(*args)
        super(""identify"", *args)
      end
",""
MiniMagick::Tool::Composite,initialize,args,"args => Array<%bot>
",true,"      def initialize(*args)
        super(""composite"", *args)
      end
",""
MiniMagick::Tool::Convert,initialize,args,"args => Array<%bot>
",true,"      def initialize(*args)
        super(""convert"", *args)
      end
",""
